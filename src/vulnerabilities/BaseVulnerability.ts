import * as fs from 'fs';
import * as path from 'path';
import { Config } from '../interfaces/config';
import { VulnerabilityReport } from '../contracts/vulnerabilityReport';
import { Vulnerability, VulnerabilityType } from '../interfaces/vulnerability';

export abstract class BaseVulnerability implements Vulnerability {
    protected config: Config;
    protected patterns: Map<string, RegExp>;
    protected messages: Map<string, string>;

    constructor(configPath: string, configSection: string) {
        const configFilePath = path.resolve(__dirname, configPath);
        this.config = JSON.parse(fs.readFileSync(configFilePath, 'utf-8'))[configSection];
        this.patterns = new Map();
        this.messages = new Map();

        // Initialize patterns and messages from the configuration
        for (const patternConfig of this.config.patterns) {
            this.patterns.set(patternConfig.name, new RegExp(patternConfig.pattern, 'g'));
            if (patternConfig.message) {
                this.messages.set(patternConfig.name, patternConfig.message);
            }
        }
    }

    // Abstract method to be implemented by derived classes
    abstract detect(code: string, filePath: string): VulnerabilityReport[];

    // Utility method to get the line number of a given index in the code
    protected getLineNumber(code: string, index: number): number {
        return code.substring(0, index).split('\n').length;
    }

    // Utility method to create a vulnerability report
    protected createReport(filePath: string, lineNumber: number, functionName: string, description: string, vulnerabilityType: VulnerabilityType): VulnerabilityReport {
        return {
            type: vulnerabilityType,
            description: `Possible vulnerability detected: ${description}.`,
            filePath: filePath,
            lineNumber: lineNumber,
            details: `The expression at line ${lineNumber} in file ${filePath} may cause a ${VulnerabilityType[vulnerabilityType]} vulnerability.`,
        };
    }

    // Common method to detect patterns in the code
    protected detectPatterns(code: string, patternName: string, filePath: string, vulnerabilityType: VulnerabilityType): VulnerabilityReport[] {
        const reports: VulnerabilityReport[] = [];
        const pattern = this.patterns.get(patternName);

        if (!pattern) {
            throw new Error(`${patternName} pattern not found in configuration.`);
        }

        const regex = new RegExp(pattern, 'g');
        let match;
        // The while loop will run as long as there are matches found in the code
        // It will break when no more matches are found
        while ((match = regex.exec(code)) !== null) {
            const startLine = this.getLineNumber(code, match.index);
            const message = this.messages.get(patternName) || `Possible ${VulnerabilityType[vulnerabilityType]} vulnerability detected`;
            reports.push(this.createReport(filePath, startLine, patternName, message, vulnerabilityType));
        }

        return reports;
    }
}
