import { VulnerabilityReport } from '../contracts/vulnerabilityReport';
import { VulnerabilityType } from '../interfaces/vulnerability';
import { BaseVulnerability } from './BaseVulnerability';

export class XSS extends BaseVulnerability {
  constructor(configPath: string) {
    super(configPath, 'xss');
  }

  detect(code: string, filePath: string): VulnerabilityReport[] {
    const reports: VulnerabilityReport[] = [];
    const unsafePattern = this.patterns.get('unsafeWritePattern');
    const safePattern = this.patterns.get('safeMethodPattern');

    if (!unsafePattern || !safePattern) {
      throw new Error('XSS patterns not found in configuration.');
    }

    const safeRegex = new RegExp(safePattern, 'g');
    let safeMatch;
    const safeIndices = [];
    while ((safeMatch = safeRegex.exec(code)) !== null) {
      safeIndices.push(safeMatch.index);
    }

    const unsafeRegex = new RegExp(unsafePattern, 'g');

    let unsafeMatch: RegExpExecArray | null;
    while ((unsafeMatch = unsafeRegex.exec(code)) !== null) {
      // PrÃ¼fen, ob die unsichere Methode in der NÃ¤he einer sicheren Methode ist
      const isSafe = safeIndices.some(safeIndex => Math.abs(safeIndex - unsafeMatch!.index) < 100); // Annahme: Sicherheitsabstand von 100 Zeichen

      if (!isSafe) {
        const startLine = this.getLineNumber(code, unsafeMatch.index);
        const message = this.messages.get("xss") || 'Possible XSS vulnerability detected';
        reports.push(this.createReport(filePath, startLine, 'xss', message, VulnerabilityType.XSS));
      }
    }
    
    return reports;
  }
}