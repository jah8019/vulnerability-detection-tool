import { VulnerabilityReport } from '../contracts/vulnerabilityReport';
import { VulnerabilityType } from '../interfaces/vulnerability';
import { BaseVulnerability } from './BaseVulnerability';

export class BufferOverflow extends BaseVulnerability {
    constructor(configPath: string) {
        super(configPath, 'bufferOverflow');
    }

    detect(code: string, filePath: string): VulnerabilityReport[] {
        const reports: VulnerabilityReport[] = [];
        const unsafePattern = this.patterns.get('unsafeBlock');

        if (!unsafePattern) {
            throw new Error('Unsafe block pattern not found in configuration.');
        }

        // Process unsafe blocks in the code
        this.processUnsafeBlocks(code, unsafePattern, filePath, reports);
        return reports;
    }

    // Process unsafe blocks and detect patterns within them
    private processUnsafeBlocks(code: string, unsafePattern: RegExp, filePath: string, reports: VulnerabilityReport[]): void {
        let match;
        // The while loop will run as long as there are matches for unsafe blocks in the code
        // It will break when no more matches are found
        while ((match = unsafePattern.exec(code)) !== null) {
            const unsafeBlock = match[1];
            const startLine = this.getLineNumber(code, match.index);

            // Detect patterns within the unsafe block
            this.detectPatternsInBlock(unsafeBlock, startLine, filePath, reports);
        }
    }

    // Detect patterns within a given block of code
    private detectPatternsInBlock(block: string, startLine: number, filePath: string, reports: VulnerabilityReport[]): void {
        for (const [name, pattern] of this.patterns.entries()) {
            if (name === 'unsafeBlock') { continue; }

            let subMatch;
            const subPattern = new RegExp(pattern.source, 'g');
            // The while loop will run as long as there are matches within the unsafe block
            // It will break when no more matches are found
            while ((subMatch = subPattern.exec(block)) !== null) {
                const message = this.messages.get(name) || `${name} used in unsafe block`;
                reports.push(this.createReport(filePath, startLine, name, message, VulnerabilityType.BufferOverflow));
            }
        }
    }
}
