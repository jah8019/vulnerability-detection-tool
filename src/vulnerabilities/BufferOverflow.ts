import { VulnerabilityReport } from '../contracts/vulnerabilityReport';
import { VulnerabilityType } from '../interfaces/vulnerability';
import { BaseVulnerability } from './BaseVulnerability';


export class BufferOverflow extends BaseVulnerability {
    constructor(configPath: string) {
        super(configPath, 'bufferOverflow');
    }

    detect(code: string, filePath: string): VulnerabilityReport[] {
        const reports: VulnerabilityReport[] = [];
        const unsafePattern = this.patterns.get('unsafeBlock');

        if (!unsafePattern) {
            throw new Error('Unsafe block pattern not found in configuration.');
        }

        let match;
        while ((match = unsafePattern.exec(code)) !== null) {
            const unsafeBlock = match[1];
            const startLine = this.getLineNumber(code, match.index);

            for (const [name, pattern] of this.patterns.entries()) {
                if (name === 'unsafeBlock') { continue; }

                let subMatch;
                const subPattern = new RegExp(pattern.source, 'g');
                while ((subMatch = subPattern.exec(unsafeBlock)) !== null) {
                    const message = this.messages.get(name) || `${name} used in unsafe block`;
                    reports.push(this.createReport(filePath, startLine, name, message, VulnerabilityType.BufferOverflow));
                }
            }
        }
        return reports;
    }
}
