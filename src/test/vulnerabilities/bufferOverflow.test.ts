import { VulnerabilityReport } from "../../contracts/vulnerabilityReport";
import { VulnerabilityType } from "../../interfaces/vulnerability";
import { BufferOverflow } from "../../vulnerabilities/BufferOverflow";

describe('BufferOverflow Tests', () => {
  let vulnerability: BufferOverflow;

  beforeEach(() => {
    vulnerability = new BufferOverflow('../../config/vulnerabilityConfig.json');
  });
  test('should detect buffer overflow vulnerability with strcpy and userInput in unsafe block', () => {
    const code = `
        unsafe {
          char[] buffer = new char[10];
          fixed (char* p = buffer) {
            strcpy(p, userInput);
          }
        }
      `;
    const filePath = 'testFile.cs';
    const results: VulnerabilityReport[] = vulnerability.detect(code, filePath);
    expect(results.length).toBe(1);
    const result = results[0];
    expect(result).not.toBeNull();
    expect(result.type).toBe(VulnerabilityType.BufferOverflow);
    expect(result.description).toBe('Possible vulnerability detected: strcpy used inside unsafe block.');
    expect(result.filePath).toBe(filePath);
    expect(result.lineNumber).toBe(2);  // Zeilennummer des unsafe Blocks
    expect(result.details).toBe('The expression at line 2 in file testFile.cs may cause a BufferOverflow vulnerability.');
  });

  test('should not detect vulnerability in safe code without unsafe block', () => {
    const code = `
        char[] buffer = new char[10];
        for (int i = 0; i < buffer.Length; i++) {
          buffer[i] = 'a';
        }
      `;
    const filePath = 'testFile.cs';
    const results: VulnerabilityReport[] = vulnerability.detect(code, filePath);
    expect(results.length).toBe(0);
  });

  test('should not detect vulnerability in code with unsafe block but no strcpy', () => {
    const code = `
        unsafe {
          char[] buffer = new char[10];
          fixed (char* p = buffer) {
            p[0] = 'a';
          }
        }
      `;
    const filePath = 'testFile.cs';
    const results: VulnerabilityReport[] = vulnerability.detect(code, filePath);
    expect(results.length).toBe(0);
  });

  test('should detect buffer overflow vulnerability with strcpy but no userInput', () => {
    const code = `
      unsafe {
        char[] buffer = new char[10];
        fixed (char* p = buffer) {
          strcpy(p, "fixedString");
        }
      }
    `;
    const filePath = 'testFile.cs';
    const results: VulnerabilityReport[] = vulnerability.detect(code, filePath);
    expect(results.length).toBe(1);
    const result = results[0];
    expect(result).not.toBeNull();
    expect(result.type).toBe(VulnerabilityType.BufferOverflow);
    expect(result.description).toBe('Possible vulnerability detected: strcpy used inside unsafe block.');
    expect(result.filePath).toBe(filePath);
    expect(result.lineNumber).toBe(2);  // Zeilennummer des unsafe Blocks
    expect(result.details).toBe('The expression at line 2 in file testFile.cs may cause a BufferOverflow vulnerability.');
  });

  test('should detect buffer overflow vulnerability with strcat and userInput', () => {
    const code = `
      unsafe {
        char[] buffer = new char[10];
        fixed (char* p = buffer) {
          strcat(p, userInput);
        }
      }
    `;
    const filePath = 'testFile.cs';
    const results: VulnerabilityReport[] = vulnerability.detect(code, filePath);
    expect(results.length).toBe(1);
    const result = results[0];
    expect(result).not.toBeNull();
    expect(result.type).toBe(VulnerabilityType.BufferOverflow);
    expect(result.description).toBe('Possible vulnerability detected: strcat used inside unsafe block.');
    expect(result.filePath).toBe(filePath);
    expect(result.lineNumber).toBe(2);  // Zeilennummer des unsafe Blocks
    expect(result.details).toBe('The expression at line 2 in file testFile.cs may cause a BufferOverflow vulnerability.');
  });
});