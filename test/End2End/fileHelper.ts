import * as fs from 'fs';
import * as path from 'path';

export class FileHelper {
    static testDirectory = path.join(__dirname, 'testDirectory');

    static createTestFiles(): void {
        if (!fs.existsSync(this.testDirectory)) {
            fs.mkdirSync(this.testDirectory);
        }

        const files = [
            {
                name: 'SQLInjection.cs',
                content: `
public class SqlInjectionExample
{
    public void ExecuteQuery(string userInput)
    {
        // Simple SQL Injection
        string query1 = "SELECT * FROM Users WHERE Username = '" + userInput + "'";
        
        // SQL Injection with concatenation
        string query2 = "SELECT * FROM Users WHERE Username = '" + userInput + "' AND Password = '" + userInput + "'";
        
        // SQL Injection in a different context
        string query3 = "DELETE FROM Users WHERE Username = '" + userInput + "'";
        
        // Concatenation with additional variables
        string tableName = "Users";
        string query4 = "SELECT * FROM " + tableName + " WHERE Username = '" + userInput + "'";
    }
}
`
            },
            {
                name: 'BufferOverflow.cs',
                content: `
using System;

public class BufferOverflowExample
{
    public void UnsafeMethod()
    {
        unsafe {
            char[] buffer = new char[10];
            fixed (char* p = buffer) {
                strcpy(p, userInput);
            }
        }

        char[] buffer = new char[10];
        for (int i = 0; i < buffer.Length; i++) {
            buffer[i] = 'a';
        }
            
        unsafe {
          char[] buffer = new char[10];
          fixed (char* p = buffer) {
            p[0] = 'a';
          }
        }

        unsafe {
            char[] buffer = new char[10];
            fixed (char* p = buffer) {
            strcpy(p, "fixedString");
            }
        }

        unsafe {
            char[] buffer = new char[10];
            fixed (char* p = buffer) {
                strcat(p, userInput);
            }
        }
    }
}
`
            },
            {
                name: 'XSS.cs',
                content: `
using System.Web;

public class XSSExample
{
    public void RenderUserInput(string userInput)
    {
        // Simple XSS vulnerability
        HttpContext.Current.Response.Write(userInput);

        // XSS in a different context
        string htmlContent = "<div>" + userInput + "</div>";
        HttpContext.Current.Response.Write(htmlContent);

        // XSS with concatenation
        string script = "<script>alert('" + userInput + "')</script>";
        HttpContext.Current.Response.Write(script);

        // XSS with additional HTML tags
        string fullHtml = "<html><body>" + userInput + "</body></html>";
        HttpContext.Current.Response.Write(fullHtml);
    }
}
`
            }
        ];

        files.forEach(file => {
            fs.writeFileSync(path.join(this.testDirectory, file.name), file.content);
        });
    }

    static cleanupTestFiles(): void {
        if (fs.existsSync(this.testDirectory)) {
            fs.readdirSync(this.testDirectory).forEach(file => {
                fs.unlinkSync(path.join(this.testDirectory, file));
            });
            fs.rmdirSync(this.testDirectory);
        }
    }
}
